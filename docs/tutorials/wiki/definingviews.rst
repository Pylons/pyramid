==============
Defining Views
==============

A :term:`view callable` in a :term:`traversal` -based :app:`Pyramid`
application is typically a simple Python function that accepts two
parameters: :term:`context` and :term:`request`.  A view callable is
assumed to return a :term:`response` object.

.. note::

   A :app:`Pyramid` view can also be defined as callable
   which accepts *only* a :term:`request` argument.  You'll see
   this one-argument pattern used in other :app:`Pyramid` tutorials
   and applications.  Either calling convention will work in any
   :app:`Pyramid` application; the calling conventions can be used
   interchangeably as necessary. In :term:`traversal` based applications,
   URLs are mapped to a context :term:`resource`, and since our
   :term:`resource tree` also represents our application's
   "domain model", we're often interested in the context, because
   it represents the persistent storage of our application.  For
   this reason, in this tutorial we define views as callables that
   accept ``context`` in the callable argument list.  If you do
   need the ``context`` within a view function that only takes
   the request as a single argument, you can obtain it via
   ``request.context``.

We're going to define several :term:`view callable` functions, then wire them
into :app:`Pyramid` using some :term:`view configuration`.


Declaring Dependencies in Our ``setup.py`` File
===============================================

The view code in our application will depend on a package which is not a
dependency of the original "tutorial" application.  The original "tutorial"
application was generated by the ``pcreate`` command; it doesn't know
about our custom application requirements.  We need to add a dependency on
the ``docutils`` package to our ``tutorial`` package's ``setup.py`` file by
assigning this dependency to the ``install_requires`` parameter in the
``setup`` function.

Our resulting ``setup.py`` should look like so:

.. literalinclude:: src/views/setup.py
   :linenos:
   :language: python

.. note:: After these new dependencies are added, you will need to
   rerun ``python setup.py develop`` inside the root of the
   ``tutorial`` package to obtain and register the newly added
   dependency package.

Adding View Functions
=====================

We're going to add four :term:`view callable` functions to our ``views.py``
module.  One view named ``view_wiki`` will display the wiki itself (it will
answer on the root URL), another named ``view_page`` will display an
individual page, another named ``add_page`` will allow a page to be added,
and a final view named ``edit_page`` will allow a page to be edited.

.. note::

  There is nothing special about the filename ``views.py``.  A project may
  have many view callables throughout its codebase in arbitrarily-named
  files.  Files implementing view callables often have ``view`` in their
  filenames (or may live in a Python subpackage of your application package
  named ``views``), but this is only by convention.

The ``view_wiki`` view function
-------------------------------

Here is the code for the ``view_wiki`` view function and its decorator, which
will be added to ``views.py``:

.. literalinclude:: src/views/tutorial/views.py
   :lines: 12-14
   :language: python

The ``view_wiki`` function will be configured to respond as the default view
callable for a Wiki resource.  We'll provide it with a ``@view_config``
decorator which names the class ``tutorial.models.Wiki`` as its context.
This means that when a Wiki resource is the context, and no :term:`view name`
exists in the request, this view will be used.  The view configuration
associated with ``view_wiki`` does not use a ``renderer`` because the view
callable always returns a :term:`response` object rather than a dictionary.
No renderer is necessary when a view returns a response object.

The ``view_wiki`` view callable always redirects to the URL of a Page
resource named "FrontPage".  To do so, it returns an instance of the
:class:`pyramid.httpexceptions.HTTPFound` class (instances of which implement
the :class:`pyramid.interfaces.IResponse` interface like
:class:`pyramid.response.Response` does).
:meth:`pyramid.request.Request.resource_url` constructs a URL to the
``FrontPage`` page resource (i.e., ``http://localhost:6543/FrontPage``), and
uses it as the "location" of the HTTPFound response, forming an HTTP
redirect.

The ``view_page`` view function
-------------------------------

Here is the code for the ``view_page`` view function and its decorator, which
will be added to ``views.py``:

.. literalinclude:: src/views/tutorial/views.py
   :lines: 16-33
   :language: python

The ``view_page`` function will be configured to respond as the default view
of a Page resource.  We'll provide it with a ``@view_config`` decorator which
names the class ``tutorial.models.Page`` as its context.  This means that
when a Page resource is the context, and no :term:`view name` exists in the
request, this view will be used.  We inform :app:`Pyramid` this view will use
the ``templates/view.pt`` template file as a ``renderer``.

The ``view_page`` function generates the :term:`reStructuredText` body of a
page (stored as the ``data`` attribute of the context passed to the view; the
context will be a Page resource) as HTML.  Then it substitutes an HTML anchor
for each *WikiWord* reference in the rendered HTML using a compiled regular
expression.

The curried function named ``check`` is used as the first argument to
``wikiwords.sub``, indicating that it should be called to provide a value for
each WikiWord match found in the content.  If the wiki (our page's
``__parent__``) already contains a page with the matched WikiWord name, the
``check`` function generates a view link to be used as the substitution value
and returns it.  If the wiki does not already contain a page with the
matched WikiWord name, the function generates an "add" link as the
substitution value and returns it.

As a result, the ``content`` variable is now a fully formed bit of HTML
containing various view and add links for WikiWords based on the content of
our current page resource.

We then generate an edit URL (because it's easier to do here than in the
template), and we wrap up a number of arguments in a dictionary and return
it.

The arguments we wrap into a dictionary include ``page``, ``content``, and
``edit_url``.  As a result, the *template* associated with this view callable
(via ``renderer=`` in its configuration) will be able to use these names to
perform various rendering tasks.  The template associated with this view
callable will be a template which lives in ``templates/view.pt``.

Note the contrast between this view callable and the ``view_wiki`` view
callable.  In the ``view_wiki`` view callable, we unconditionally return a
:term:`response` object.  In the ``view_page`` view callable, we return a
*dictionary*.  It is *always* fine to return a :term:`response` object from a
:app:`Pyramid` view.  Returning a dictionary is allowed only when there is a
:term:`renderer` associated with the view callable in the view configuration.

The ``add_page`` view function
------------------------------

Here is the code for the ``add_page`` view function and its decorator, which
will be added to ``views.py``:

.. literalinclude:: src/views/tutorial/views.py
   :lines: 35-50
   :language: python

The ``add_page`` function will be configured to respond when the context
resource is a Wiki and the :term:`view name` is ``add_page``.  We'll provide
it with a ``@view_config`` decorator which names the string ``add_page`` as
its :term:`view name` (via name=), the class ``tutorial.models.Wiki`` as its
context, and the renderer named ``templates/edit.pt``.  This means that when
a Wiki resource is the context, and a :term:`view name` named ``add_page``
exists as the result of traversal, this view will be used.  We inform
:app:`Pyramid` this view will use the ``templates/edit.pt`` template file as
a ``renderer``.  We share the same template between add and edit views, thus
``edit.pt`` instead of ``add.pt``.

The ``add_page`` function will be invoked when a user clicks on a WikiWord
which isn't yet represented as a page in the system.  The ``check`` function
within the ``view_page`` view generates URLs to this view.  It also acts as a
handler for the form that is generated when we want to add a page resource.
The ``context`` of the ``add_page`` view is always a Wiki resource (*not* a
Page resource).

The request :term:`subpath` in :app:`Pyramid` is the sequence of names that
are found *after* the :term:`view name` in the URL segments given in the
``PATH_INFO`` of the WSGI request as the result of :term:`traversal`.  If our
add view is invoked via, e.g. ``http://localhost:6543/add_page/SomeName``,
the :term:`subpath` will be a tuple: ``('SomeName',)``.

The add view takes the zeroth element of the subpath (the wiki page name),
and aliases it to the name attribute in order to know the name of the page
we're trying to add.

If the view rendering is *not* a result of a form submission (if the
expression ``'form.submitted' in request.params`` is ``False``), the view
renders a template.  To do so, it generates a "save url" which the template
uses as the form post URL during rendering.  We're lazy here, so we're trying
to use the same template (``templates/edit.pt``) for the add view as well as
the page edit view.  To do so, we create a dummy Page resource object in
order to satisfy the edit form's desire to have *some* page object exposed as
``page``, and we'll render the template to a response.

If the view rendering *is* a result of a form submission (if the expression
``'form.submitted' in request.params`` is ``True``), we scrape the page body
from the form data, create a Page object using the name in the subpath and
the page body, and save it into "our context" (the Wiki) using the
``__setitem__`` method of the context. We then redirect back to the
``view_page`` view (the default view for a page) for the newly created page.

The ``edit_page`` view function
-------------------------------

Here is the code for the ``edit_page`` view function and its decorator, which
will be added to ``views.py``:

.. literalinclude:: src/views/tutorial/views.py
   :lines: 52-60
   :language: python

The ``edit_page`` function will be configured to respond when the context is
a Page resource and the :term:`view name` is ``edit_page``.  We'll provide it
with a ``@view_config`` decorator which names the string ``edit_page`` as its
:term:`view name` (via ``name=``), the class ``tutorial.models.Page`` as its
context, and the renderer named ``templates/edit.pt``.  This means that when
a Page resource is the context, and a :term:`view name` exists as the result
of traversal named ``edit_page``, this view will be used.  We inform
:app:`Pyramid` this view will use the ``templates/edit.pt`` template file as
a ``renderer``.

The ``edit_page`` function will be invoked when a user clicks the "Edit this
Page" button on the view form.  It renders an edit form but it also acts as
the form post view callable for the form it renders.  The ``context`` of the
``edit_page`` view will *always* be a Page resource (never a Wiki resource).

If the view execution is *not* a result of a form submission (if the
expression ``'form.submitted' in request.params`` is ``False``), the view
simply renders the edit form, passing the page resource, and a ``save_url``
which will be used as the action of the generated form.

If the view execution *is* a result of a form submission (if the expression
``'form.submitted' in request.params`` is ``True``), the view grabs the
``body`` element of the request parameter and sets it as the ``data``
attribute of the page context.  It then redirects to the default view of the
context (the page), which will always be the ``view_page`` view.

Viewing the Result of all Our Edits to ``views.py``
===================================================

The result of all of our edits to ``views.py`` will leave it looking like
this:

.. literalinclude:: src/views/tutorial/views.py
   :linenos:
   :language: python

Adding Templates
================

The ``view_page``, ``add_page`` and ``edit_page`` views that we've added
reference a :term:`template`.  Each template is a :term:`Chameleon` :term:`ZPT`
template.  These templates will live in the ``templates`` directory of our
tutorial package.  Chameleon templates must have a ``.pt`` extension to be
recognized as such.

The ``view.pt`` Template
------------------------

Create ``tutorial/tutorial/templates/view.pt`` and add the following
content:

.. literalinclude:: src/views/tutorial/templates/view.pt
   :linenos:
   :language: xml

This template is used by ``view_page()`` for displaying a single
wiki page. It includes:

- A ``div`` element that is replaced with the ``content``
  value provided by the view (rows 45-47).  ``content``
  contains HTML, so the ``structure`` keyword is used
  to prevent escaping it (i.e. changing ">" to "&gt;", etc.)
- A link that points
  at the "edit" URL which invokes the ``edit_page`` view for
  the page being viewed (rows 49-51).

The ``edit.pt`` Template
------------------------

Create ``tutorial/tutorial/templates/edit.pt`` and add the following
content:

.. literalinclude:: src/views/tutorial/templates/edit.pt
   :linenos:
   :language: xml

This template is used by ``add_page()`` and ``edit_page()`` for adding
and editing a wiki page.  It displays
a page containing a form that includes:

- A 10 row by 60 column ``textarea`` field named ``body`` that is filled
  with any existing page data when it is rendered (rows 46-47).
- A submit button that has the name ``form.submitted`` (row 48).

The form POSTs back to the "save_url" argument supplied
by the view (row 45).  The view will use the ``body`` and
``form.submitted`` values.

.. note:: Our templates use a ``request`` object that
   none of our tutorial views return in their dictionary.
   ``request`` is one of several
   names that are available "by default" in a template when a template
   renderer is used.  See :ref:`renderer_system_values` for
   information about other names that are available by default
   when a template is used as a renderer.

Static Assets
-------------

Our templates name a single static asset named ``pylons.css``.  We don't need
to create this file within our package's ``static`` directory because it was
provided at the time we created the project. This file is a little too long to
replicate within the body of this guide, however it is available `online
<https://github.com/Pylons/pyramid/blob/master/docs/tutorials/wiki/src/views/tutorial/static/pylons.css>`_.

This CSS file will be accessed via
e.g. ``/static/pylons.css`` by virtue of the call to
``add_static_view`` directive we've made in the ``__init__.py`` file.  Any
number and type of static assets can be placed in this directory (or
subdirectories) and are just referred to by URL.

Viewing the Application in a Browser
====================================

We can finally examine our application in a browser (See
:ref:`wiki-start-the-application`).  Launch a browser and visit
each of the following URLs, check that the result is as expected:

- ``http://localhost:6543/`` invokes the ``view_wiki``
  view.  This always redirects to the ``view_page`` view of the ``FrontPage``
  Page resource.

- ``http://localhost:6543/FrontPage/`` invokes
  the ``view_page`` view of the front page resource.  This is
  because it's the :term:`default view` (a view without a ``name``) for Page
  resources.

- ``http://localhost:6543/FrontPage/edit_page``
  invokes the edit view for the ``FrontPage`` Page resource.

- ``http://localhost:6543/add_page/SomePageName``
  invokes the add view for a Page.

- To generate an error, visit ``http://localhost:6543/add_page`` which
  will generate an ``IndexErrorr: tuple index out of range`` error.
  You'll see an interactive traceback
  facility provided by :term:`pyramid_debugtoolbar`.
