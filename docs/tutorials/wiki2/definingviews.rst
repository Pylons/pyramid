==============
Defining Views
==============

A :term:`view callable` in a :app:`Pyramid` application is typically a simple
Python function that accepts a single parameter named :term:`request`.  A
view callable is assumed to return a :term:`response` object.

The request object passed to every view that is called as the result of a
route match has an attribute named ``matchdict`` that contains the elements
placed into the URL by the ``pattern`` of a ``route`` statement.  For
instance, if a call to :meth:`pyramid.config.Configurator.add_route` in
``__init__.py`` had the pattern ``{one}/{two}``, and the URL at
``http://example.com/foo/bar`` was invoked, matching this pattern, the
``matchdict`` dictionary attached to the request passed to the view would
have a ``'one'`` key with the value ``'foo'`` and a ``'two'`` key with the
value ``'bar'``.

The source code for this tutorial stage can be browsed at
`http://github.com/Pylons/pyramid/tree/master/docs/tutorials/wiki2/src/views/
<http://github.com/Pylons/pyramid/tree/master/docs/tutorials/wiki2/src/views/>`_.

Declaring Dependencies in Our ``setup.py`` File
===============================================

The view code in our application will depend on a package which is not a
dependency of the original "tutorial" application.  The original "tutorial"
application was generated by the ``pcreate`` command; it doesn't know
about our custom application requirements.  We need to add a dependency on
the ``docutils`` package to our ``tutorial`` package's ``setup.py`` file by
assigning this dependency to the ``install_requires`` parameter in the
``setup`` function.

Our resulting ``setup.py`` should look like so:

.. literalinclude:: src/views/setup.py
   :linenos:
   :language: python

Running ``setup.py develop``
============================

Since a new software dependency was added, you will need to rerun ``python
setup.py develop`` inside the root of the ``tutorial`` package to obtain and
register the newly added dependency distribution.

Make sure your current working directory is the root of the project (the
directory in which setup.py lives) and execute the following command.

On UNIX:

.. code-block:: text

   $ cd tutorial
   $ ../bin/python setup.py develop

On Windows:

.. code-block:: text

   c:\pyramidtut> cd tutorial
   c:\pyramidtut\tutorial> ..\Scripts\python setup.py develop

Success executing this command will end with a line to the console something
like::

   Finished processing dependencies for tutorial==0.0

Changing the ``views.py`` File
==============================

We're going to edit our ``views.py`` in a rather major way.  The result of
all of our edits to ``views.py`` will leave it looking like this:

.. literalinclude:: src/views/tutorial/views.py
   :linenos:
   :language: python

We've gotten rid of the ``my_view`` view function and its decorator that was
added when we originally rendered the ``alchemy`` scaffold.  It was only an
example and isn't relevant to our application.

Then we added four :term:`view callable` functions to our ``views.py``
module.  One view callable (named ``view_wiki``) will display the wiki itself
(it will answer on the root URL), another named ``view_page`` will display an
individual page, another named ``add_page`` will allow a page to be added,
and a final view callable named ``edit_page`` will allow a page to be edited.
We'll describe each one briefly and show the resulting ``views.py`` file
afterward.

.. note::

  There is nothing special about the filename ``views.py``.  A project may
  have many view callables throughout its codebase in arbitrarily-named
  files.  Files implementing view callables often have ``view`` in their
  filenames (or may live in a Python subpackage of your application package
  named ``views``), but this is only by convention.

The ``view_wiki`` view function
-------------------------------

The ``view_wiki`` function is the :term:`default view` that will be called
when a request is made to the root URL of our wiki.  It always redirects to
a URL which represents the path to our "FrontPage".

.. literalinclude:: src/views/tutorial/views.py
   :lines: 18-21
   :linenos:
   :language: python

The ``view_wiki`` function returns an instance of the
:class:`pyramid.httpexceptions.HTTPFound` class (instances of which implement
the :class:`pyramid.interfaces.IResponse` interface like
:class:`pyramid.response.Response` does), It will use the
:meth:`pyramid.request.Request.route_url` API to construct a URL to the
``FrontPage`` page (e.g. ``http://localhost:6543/FrontPage``), and will use
it as the "location" of the HTTPFound response, forming an HTTP redirect.

The ``view_page`` view function
-------------------------------

The ``view_page`` function will be used to show a single page of our
wiki.  It renders the :term:`ReStructuredText` body of a page (stored as
the ``data`` attribute of a Page object) as HTML.  Then it substitutes an
HTML anchor for each *WikiWord* reference in the rendered HTML using a
compiled regular expression.

.. literalinclude:: src/views/tutorial/views.py
   :lines: 23-44
   :linenos:
   :language: python

The curried function named ``check`` is used as the first argument to
``wikiwords.sub``, indicating that it should be called to provide a value for
each WikiWord match found in the content.  If the wiki already contains a
page with the matched WikiWord name, the ``check`` function generates a view
link to be used as the substitution value and returns it.  If the wiki does
not already contain a page with with the matched WikiWord name, the function
generates an "add" link as the substitution value and returns it.

As a result, the ``content`` variable is now a fully formed bit of HTML
containing various view and add links for WikiWords based on the content of
our current page object.

We then generate an edit URL (because it's easier to do here than in the
template), and we return a dictionary with a number of arguments.  The fact
that this view returns a dictionary (as opposed to a :term:`response` object)
is a cue to :app:`Pyramid` that it should try to use a :term:`renderer`
associated with the view configuration to render a template.  In our case,
the template which will be rendered will be the ``templates/view.pt``
template, as per the configuration put into effect in ``__init__.py``.

The ``add_page`` view function
------------------------------

The ``add_page`` function will be invoked when a user clicks on a *WikiWord*
which isn't yet represented as a page in the system.  The ``check`` function
within the ``view_page`` view generates URLs to this view.  It also acts as a
handler for the form that is generated when we want to add a page object.
The ``matchdict`` attribute of the request passed to the ``add_page`` view
will have the values we need to construct URLs and find model objects.

.. literalinclude:: src/views/tutorial/views.py
   :lines: 46-58
   :linenos:
   :language: python

The ``matchdict`` will have a ``'pagename'`` key that matches the name of
the page we'd like to add.  If our add view is invoked via,
e.g. ``http://localhost:6543/add_page/SomeName``, the value for
``'pagename'`` in the ``matchdict`` will be ``'SomeName'``.

If the view execution is *not* a result of a form submission (if the
expression ``'form.submitted' in request.params`` is ``False``), the view
callable renders a template.  To do so, it generates a "save url" which the
template uses as the form post URL during rendering.  We're lazy here, so
we're trying to use the same template (``templates/edit.pt``) for the add
view as well as the page edit view, so we create a dummy Page object in order
to satisfy the edit form's desire to have *some* page object exposed as
``page``, and :app:`Pyramid` will render the template associated with this
view to a response.

If the view execution *is* a result of a form submission (if the expression
``'form.submitted' in request.params`` is ``True``), we scrape the page body
from the form data, create a Page object with this page body and the name
taken from ``matchdict['pagename']``, and save it into the database using
``session.add``.  We then redirect back to the ``view_page`` view for the
newly created page.

The ``edit_page`` view function
-------------------------------

The ``edit_page`` function will be invoked when a user clicks the "Edit this
Page" button on the view form.  It renders an edit form but it also acts as
the handler for the form it renders.  The ``matchdict`` attribute of the
request passed to the ``edit_page`` view will have a ``'pagename'`` key
matching the name of the page the user wants to edit.

.. literalinclude:: src/views/tutorial/views.py
   :lines: 60-73
   :linenos:
   :language: python

If the view execution is *not* a result of a form submission (if the
expression ``'form.submitted' in request.params`` is ``False``), the view
simply renders the edit form, passing the page object and a ``save_url``
which will be used as the action of the generated form.

If the view execution *is* a result of a form submission (if the expression
``'form.submitted' in request.params`` is ``True``), the view grabs the
``body`` element of the request parameters and sets it as the ``data``
attribute of the page object.  It then redirects to the ``view_page`` view
of the wiki page.

Adding Templates
================

The views we've added all reference a :term:`template`.  Each template is a
:term:`Chameleon` :term:`ZPT` template.  These templates will live in the
``templates`` directory of our tutorial package.

The ``view.pt`` Template
------------------------

The ``view.pt`` template is used for viewing a single wiki page.  It is used
by the ``view_page`` view function.  It should have a div that is "structure
replaced" with the ``content`` value provided by the view.  It should also
have a link on the rendered page that points at the "edit" URL (the URL which
invokes the ``edit_page`` view for the page being viewed).

Once we're done with the ``view.pt`` template, it will look a lot like the
below:

.. literalinclude:: src/views/tutorial/templates/view.pt
   :language: xml

.. note:: The names available for our use in a template are always
   those that are present in the dictionary returned by the view
   callable.  But our templates make use of a ``request`` object that
   none of our tutorial views return in their dictionary.  This value
   appears as if "by magic".  However, ``request`` is one of several
   names that are available "by default" in a template when a template
   renderer is used.  See :ref:`chameleon_template_renderers` for more
   information about other names that are available by default in a
   template when a Chameleon template is used as a renderer.

The ``edit.pt`` Template
------------------------

The ``edit.pt`` template is used for adding and editing a wiki page.  It is
used by the ``add_page`` and ``edit_page`` view functions.  It should display
a page containing a form that POSTs back to the "save_url" argument supplied
by the view.  The form should have a "body" textarea field (the page data),
and a submit button that has the name "form.submitted".  The textarea in the
form should be filled with any existing page data when it is rendered.

Once we're done with the ``edit.pt`` template, it will look a lot like
the below:

.. literalinclude:: src/views/tutorial/templates/edit.pt
   :language: xml

Static Assets
-------------

Our templates name a single static asset named ``pylons.css``.  We don't need
to create this file within our package's ``static`` directory because it was
provided at the time we created the project. This file is a little too long
to replicate within the body of this guide, however it is available `online
<http://github.com/Pylons/pyramid/blob/master/docs/tutorials/wiki2/src/views/tutorial/static/pylons.css>`_.

This CSS file will be accessed via
e.g. ``http://localhost:6543/static/pylons.css`` by virtue of the call to
``add_static_view`` directive we've made in the ``__init__.py`` file.  Any
number and type of static assets can be placed in this directory (or
subdirectories) and are just referred to by URL or by using the convenience
method ``static_url``
e.g. ``request.static_url('{{package}}:static/foo.css')`` within templates.

Adding Routes to ``__init__.py``
================================

The ``__init__.py`` file contains
:meth:`pyramid.config.Configurator.add_route` calls which serve to add routes
to our application.  First, we’ll get rid of the existing route created by
the template using the name ``'home'``. It’s only an example and isn’t
relevant to our application.

We then need to add four calls to ``add_route``.  Note that the *ordering* of
these declarations is very important.  ``route`` declarations are matched in
the order they're found in the ``__init__.py`` file.

#. Add a declaration which maps the pattern ``/`` (signifying the root URL)
   to the route named ``view_wiki``.  It maps to our ``view_wiki`` view
   callable by virtue of the ``@view_config`` attached to the ``view_wiki``
   view function indicating ``route_name='view_wiki'``.

#. Add a declaration which maps the pattern ``/{pagename}`` to the route named
   ``view_page``.  This is the regular view for a page.  It maps
   to our ``view_page`` view callable by virtue of the ``@view_config``
   attached to the ``view_page`` view function indicating
   ``route_name='view_page'``.

#. Add a declaration which maps the pattern ``/add_page/{pagename}`` to the
   route named ``add_page``.  This is the add view for a new page.  It maps
   to our ``add_page`` view callable by virtue of the ``@view_config``
   attached to the ``add_page`` view function indicating
   ``route_name='add_page'``.

#. Add a declaration which maps the pattern ``/{pagename}/edit_page`` to the
   route named ``edit_page``.  This is the edit view for a page.  It maps
   to our ``edit_page`` view callable by virtue of the ``@view_config``
   attached to the ``edit_page`` view function indicating
   ``route_name='edit_page'``.

As a result of our edits, the ``__init__.py`` file should look
something like so:

.. literalinclude:: src/views/tutorial/__init__.py
   :linenos:
   :language: python

Viewing the Application in a Browser
====================================

We can finally examine our application in a browser.  The views we'll try are
as follows:

- Visiting ``http://localhost:6543`` in a browser invokes the
  ``view_wiki`` view.  This always redirects to the ``view_page`` view
  of the FrontPage page object.

- Visiting ``http://localhost:6543/FrontPage`` in a browser invokes
  the ``view_page`` view of the front page page object.

- Visiting ``http://localhost:6543/FrontPage/edit_page`` in a browser
  invokes the edit view for the front page object.

- Visiting ``http://localhost:6543/add_page/SomePageName`` in a
  browser invokes the add view for a page.

Try generating an error within the body of a view by adding code to
the top of it that generates an exception (e.g. ``raise
Exception('Forced Exception')``).  Then visit the error-raising view
in a browser.  You should see an interactive exception handler in the
browser which allows you to examine values in a post-mortem mode.

