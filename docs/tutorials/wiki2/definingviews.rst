==============
Defining Views
==============

A :term:`view callable` in a :app:`Pyramid` application is typically a simple
Python function that accepts a single parameter named :term:`request`.  A
view callable is assumed to return a :term:`response` object.

The request object has a dictionary as an attribute named ``matchdict``.  A
``matchdict`` maps the placeholders in the matching URL ``pattern`` to the
substrings of the path in the :term:`request` URL. For instance, if a call to
:meth:`pyramid.config.Configurator.add_route` has the pattern ``/{one}/{two}``,
and a user visits ``http://example.com/foo/bar``, our pattern would be matched
against ``/foo/bar`` and the ``matchdict`` would look like ``{'one':'foo',
'two':'bar'}``.

Declaring Dependencies in Our ``setup.py`` File
===============================================

The view code in our application will depend on a package which is not a
dependency of the original "tutorial" application.  The original "tutorial"
application was generated by the ``pcreate`` command; it doesn't know
about our custom application requirements.

We need to add a dependency on the ``docutils`` package to our ``tutorial``
package's ``setup.py`` file by assigning this dependency to the ``requires``
parameter in the ``setup()`` function.

Open ``tutorial/setup.py`` and edit it to look like the following:

.. literalinclude:: src/views/setup.py
   :linenos:
   :emphasize-lines: 20
   :language: python

Only the highlighted line needs to be added.

Running ``setup.py develop``
============================

Since a new software dependency was added, you will need to run ``python
setup.py develop`` again inside the root of the ``tutorial`` package to obtain
and register the newly added dependency distribution.

Make sure your current working directory is the root of the project (the
directory in which ``setup.py`` lives) and execute the following command.

On UNIX:

.. code-block:: text

   $ cd tutorial
   $ $VENV/bin/python setup.py develop

On Windows:

.. code-block:: text

   c:\pyramidtut> cd tutorial
   c:\pyramidtut\tutorial> %VENV%\Scripts\python setup.py develop

Success executing this command will end with a line to the console something
like::

   Finished processing dependencies for tutorial==0.0

Adding view functions in ``views.py``
=====================================

It's time for a major change.  Open ``tutorial/tutorial/views.py`` and edit it
to look like the following:

.. literalinclude:: src/views/tutorial/views.py
   :linenos:
   :language: python
   :emphasize-lines: 1-7,14,16-72

The highlighted lines need to be added or edited.

We added some imports and created a regular expression to find "WikiWords".

We got rid of the ``my_view`` view function and its decorator that was added
when we originally rendered the ``alchemy`` scaffold.  It was only an example
and isn't relevant to our application.

Then we added four :term:`view callable` functions to our ``views.py``
module: 

* ``view_wiki()`` - Displays the wiki itself. It will answer on the root URL.
* ``view_page()`` - Displays an individual page.
* ``add_page()`` - Allows the user to add a page.
* ``edit_page()`` - Allows the user to edit a page.

We'll describe each one briefly in the following sections.

.. note::

  There is nothing special about the filename ``views.py``.  A project may
  have many view callables throughout its codebase in arbitrarily named
  files.  Files implementing view callables often have ``view`` in their
  filenames (or may live in a Python subpackage of your application package
  named ``views``), but this is only by convention.

The ``view_wiki`` view function
-------------------------------

Following is the code for the ``view_wiki`` view function and its decorator:

.. literalinclude:: src/views/tutorial/views.py
   :lines: 20-24
   :lineno-start: 20
   :linenos:
   :language: python

``view_wiki()`` is the :term:`default view` that gets called when a request is
made to the root URL of our wiki.  It always redirects to an URL which
represents the path to our "FrontPage".

The ``view_wiki`` view callable always redirects to the URL of a Page resource
named "FrontPage".  To do so, it returns an instance of the
:class:`pyramid.httpexceptions.HTTPFound` class (instances of which implement
the :class:`pyramid.interfaces.IResponse` interface, like
:class:`pyramid.response.Response` does). It uses the
:meth:`pyramid.request.Request.route_url` API to construct an URL to the
``FrontPage`` page (i.e., ``http://localhost:6543/FrontPage``), and uses it as
the "location" of the ``HTTPFound`` response, forming an HTTP redirect.

The ``view_page`` view function
-------------------------------

Here is the code for the ``view_page`` view function and its decorator:

.. literalinclude:: src/views/tutorial/views.py
   :lines: 25-45
   :lineno-start: 25
   :linenos:
   :language: python

``view_page()`` is used to display a single page of our wiki.  It renders the
:term:`reStructuredText` body of a page (stored as the ``data`` attribute of a
``Page`` model object) as HTML.  Then it substitutes an HTML anchor for each
*WikiWord* reference in the rendered HTML using a compiled regular expression.

The curried function named ``check`` is used as the first argument to
``wikiwords.sub``, indicating that it should be called to provide a value for
each WikiWord match found in the content.  If the wiki already contains a
page with the matched WikiWord name, ``check()`` generates a view
link to be used as the substitution value and returns it.  If the wiki does
not already contain a page with the matched WikiWord name, ``check()``
generates an "add" link as the substitution value and returns it.

As a result, the ``content`` variable is now a fully formed bit of HTML
containing various view and add links for WikiWords based on the content of
our current page object.

We then generate an edit URL because it's easier to do here than in the
template, and we return a dictionary with a number of arguments.  The fact that
``view_page()`` returns a dictionary (as opposed to a :term:`response` object)
is a cue to :app:`Pyramid` that it should try to use a :term:`renderer`
associated with the view configuration to render a response.  In our case, the
renderer used will be the ``templates/view.pt`` template, as indicated in the
``@view_config`` decorator that is applied to ``view_page()``.

The ``add_page`` view function
------------------------------

Here is the code for the ``add_page`` view function and its decorator:

.. literalinclude:: src/views/tutorial/views.py
   :lines: 47-58
   :lineno-start: 47
   :linenos:
   :language: python

``add_page()`` is invoked when a user clicks on a *WikiWord* which
isn't yet represented as a page in the system.  The ``check`` function
within the ``view_page`` view generates URLs to this view.
``add_page()`` also acts as a handler for the form that is generated
when we want to add a page object.  The ``matchdict`` attribute of the
request passed to the ``add_page()`` view will have the values we need
to construct URLs and find model objects.

The ``matchdict`` will have a ``'pagename'`` key that matches the name of
the page we'd like to add.  If our add view is invoked via,
e.g., ``http://localhost:6543/add_page/SomeName``, the value for
``'pagename'`` in the ``matchdict`` will be ``'SomeName'``.

If the view execution *is* a result of a form submission (i.e., the expression
``'form.submitted' in request.params`` is ``True``), we grab the page body
from the form data, create a Page object with this page body and the name
taken from ``matchdict['pagename']``, and save it into the database using
``DBSession.add``.  We then redirect back to the ``view_page`` view for the
newly created page.

If the view execution is *not* a result of a form submission (i.e., the
expression ``'form.submitted' in request.params`` is ``False``), the view
callable renders a template.  To do so, it generates a ``save_url`` which the
template uses as the form post URL during rendering.  We're lazy here, so
we're going to use the same template (``templates/edit.pt``) for the add
view as well as the page edit view. To do so we create a dummy Page object
in order to satisfy the edit form's desire to have *some* page object
exposed as ``page``. :app:`Pyramid` will render the template associated
with this view to a response.

The ``edit_page`` view function
-------------------------------

Here is the code for the ``edit_page`` view function and its decorator:

.. literalinclude:: src/views/tutorial/views.py
   :lines: 60-72
   :lineno-start: 60
   :linenos:
   :language: python

``edit_page()`` is invoked when a user clicks the "Edit this
Page" button on the view form.  It renders an edit form but it also acts as
the handler for the form it renders.  The ``matchdict`` attribute of the
request passed to the ``edit_page`` view will have a ``'pagename'`` key
matching the name of the page the user wants to edit.

If the view execution *is* a result of a form submission (i.e., the expression
``'form.submitted' in request.params`` is ``True``), the view grabs the
``body`` element of the request parameters and sets it as the ``data``
attribute of the page object.  It then redirects to the ``view_page`` view
of the wiki page.

If the view execution is *not* a result of a form submission (i.e., the
expression ``'form.submitted' in request.params`` is ``False``), the view
simply renders the edit form, passing the page object and a ``save_url``
which will be used as the action of the generated form.

Adding templates
================

The ``view_page``, ``add_page`` and ``edit_page`` views that we've added
reference a :term:`template`.  Each template is a :term:`Chameleon`
:term:`ZPT` template.  These templates will live in the ``templates``
directory of our tutorial package.  Chameleon templates must have a ``.pt``
extension to be recognized as such.

The ``view.pt`` template
------------------------

Create ``tutorial/tutorial/templates/view.pt`` and add the following
content:

.. literalinclude:: src/views/tutorial/templates/view.pt
   :linenos:
   :language: html

This template is used by ``view_page()`` for displaying a single
wiki page. It includes:

- A ``div`` element that is replaced with the ``content`` value provided by
  the view (lines 36-38).  ``content`` contains HTML, so the ``structure``
  keyword is used to prevent escaping it (i.e., changing ">" to "&gt;", etc.)
- A link that points at the "edit" URL which invokes the ``edit_page`` view
  for the page being viewed (lines 40-42).

The ``edit.pt`` template
------------------------

Create ``tutorial/tutorial/templates/edit.pt`` and add the following
content:

.. literalinclude:: src/views/tutorial/templates/edit.pt
   :linenos:
   :language: html

This template is used by ``add_page()`` and ``edit_page()`` for adding and
editing a wiki page.  It displays a page containing a form that includes:

- A 10 row by 60 column ``textarea`` field named ``body`` that is filled
  with any existing page data when it is rendered (line 45).
- A submit button that has the name ``form.submitted`` (line 48).

The form POSTs back to the ``save_url`` argument supplied by the view (line
43).  The view will use the ``body`` and ``form.submitted`` values.

.. note:: Our templates use a ``request`` object that none of our tutorial
   views return in their dictionary. ``request`` is one of several names that
   are available "by default" in a template when a template renderer is used.
   See :ref:`renderer_system_values` for information about other names that
   are available by default when a template is used as a renderer.

Static Assets
-------------

Our templates name static assets, including CSS and images.  We don't need
to create these files within our package's ``static`` directory because they
were provided at the time we created the project.

As an example, the CSS file will be accessed via
``http://localhost:6543/static/theme.css`` by virtue of the call to the
``add_static_view`` directive we've made in the ``__init__.py`` file.  Any
number and type of static assets can be placed in this directory (or
subdirectories) and are just referred to by URL or by using the convenience
method ``static_url``, e.g.,
``request.static_url('<package>:static/foo.css')`` within templates.

Adding Routes to ``__init__.py``
================================

The ``__init__.py`` file contains
:meth:`pyramid.config.Configurator.add_route` calls which serve to add routes
to our application.  First, we’ll get rid of the existing route created by
the template using the name ``'home'``. It’s only an example and isn’t
relevant to our application.

We then need to add four calls to ``add_route``.  Note that the *ordering* of
these declarations is very important.  ``route`` declarations are matched in
the order they're found in the ``__init__.py`` file.

#. Add a declaration which maps the pattern ``/`` (signifying the root URL)
   to the route named ``view_wiki``.  It maps to our ``view_wiki`` view
   callable by virtue of the ``@view_config`` attached to the ``view_wiki``
   view function indicating ``route_name='view_wiki'``.

#. Add a declaration which maps the pattern ``/{pagename}`` to the route named
   ``view_page``.  This is the regular view for a page.  It maps
   to our ``view_page`` view callable by virtue of the ``@view_config``
   attached to the ``view_page`` view function indicating
   ``route_name='view_page'``.

#. Add a declaration which maps the pattern ``/add_page/{pagename}`` to the
   route named ``add_page``.  This is the add view for a new page.  It maps
   to our ``add_page`` view callable by virtue of the ``@view_config``
   attached to the ``add_page`` view function indicating
   ``route_name='add_page'``.

#. Add a declaration which maps the pattern ``/{pagename}/edit_page`` to the
   route named ``edit_page``.  This is the edit view for a page.  It maps
   to our ``edit_page`` view callable by virtue of the ``@view_config``
   attached to the ``edit_page`` view function indicating
   ``route_name='edit_page'``.

As a result of our edits, the ``__init__.py`` file should look
something like:

.. literalinclude:: src/views/tutorial/__init__.py
   :linenos:
   :emphasize-lines: 19-22
   :language: python

The highlighted lines are the ones that need to be added or edited.

Viewing the application in a browser
====================================

We can finally examine our application in a browser (See
:ref:`wiki2-start-the-application`).  Launch a browser and visit
each of the following URLs, checking that the result is as expected:

- http://localhost:6543/ invokes the ``view_wiki`` view.  This always
  redirects to the ``view_page`` view of the ``FrontPage`` page object.

- http://localhost:6543/FrontPage invokes the ``view_page`` view of the front
  page object.

- http://localhost:6543/FrontPage/edit_page invokes the edit view for the
  front page object.

- http://localhost:6543/add_page/SomePageName invokes the add view for a page.

- To generate an error, visit http://localhost:6543/foobars/edit_page which
  will generate a ``NoResultFound: No row was found for one()`` error. You'll
  see an interactive traceback facility provided by
  :term:`pyramid_debugtoolbar`.
